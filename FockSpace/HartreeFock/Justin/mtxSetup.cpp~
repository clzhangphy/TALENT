#include <iostream>
#include <fstream>
#include <cmath>

using namespace std;


double simp(double rmin, double rmax, int max_step, int i, int j, int l,
	    double nu);
double func(int i, int j, int l, double r, double nu);
double radiallogs(int n, int l, double r, double nu);
double recursive(int n, double alpha, double x);
double logfact(int n);
double logoddfact(int n);


ofstream mtxFile;


int main()
{
  mtxFile.open("mtxFile.dat");

  mtxFile << "# number of matrix elements (only non-zero cases)" << endl;
  mtxFile << "3" << endl;
  mtxFile << "1 2 1 2 -1.0" << endl;
  mtxFile << "1 2 3 4 -1.0" << endl;
  mtxFile << "3 4 3 4 -1.0" << endl;

  cout << "Kowabunga Dude. Totally GnarGnar." << endl;

  mtxFile.close();

  return 0;
}

// gets accuracy up to 10^-12 at around 10^3 steps
double simp(double rmin, double rmax, int max_step, int i, int j, int l,
	    double nu)
{
  int k;
  double r,rstep, integ, fa, fb;
  rstep = (rmax-rmin)/max_step;
  integ = 0.0;

  fa = func(i,j,l,rmin,nu)*rstep;
  fb = func(i,j,l,rmax,nu)*rstep;

  for(k=1; k<=max_step-1; k++)
    {
      r = rmin + k*rstep;
      if(k%2 == 0)
	{
	  integ += 2*func(i,j,l,r,nu)*rstep;
	}
      else
	{
	  integ += 4*func(i,j,l,r,nu)*rstep;
	}
    }

  integ = (integ+fa+fb)/3.0;
  return integ;
  
} // end simp


double func(int i, int j, int l, double r, double nu)
{
  //return r*r*radiallogs(i,l,r)*potential(r)*radiallogs(j,l,r);
  return -r*radiallogs(i,l,r,nu)*radiallogs(j,l,r,nu);
} //end func


double radiallogs(int n, int l, double r, double nu)
{
  // v = nu = m*omega/(2*h_bar) this is different from practioners!
  double logcoeff, R,coeff;
  //v = 4.0;  // this is the nu from wikipedia.
  // v = 0.5 will diagonalize the HO potential
  
  //logcoeff = 0.5*(1.5*log(v) + (l-n+2)*log(2) + logoddfact(2*n+2*l+1)) 
   // -0.5*(0.5*log(M_PI) + logfact(n) + 2*logoddfact(2*l+1));
  

  logcoeff = 0.5*((1.5+l)*log(nu) + (n+2*l+3.5)*log(2) + logfact(n)
		  - 0.5*log(M_PI) - logoddfact(2*n+2*l+1));
	
 
  
  R = exp(logcoeff)*pow(r,l)*recursive(n,l+0.5,2.0*nu*r*r)*exp(-nu*r*r);
  
  return R;
}

// give generalized laguerre poly at a point x
double recursive(int n, double alpha, double x)
{
  if(n == 0)
    {
      return 1.0;
    }
  if(n == 1)
    {
      return 1.0 + alpha - x;
    }
  else
    {
      int k;
      double L[n+1];
      L[0] = 1.0;
      L[1] = 1.0 + alpha - x;
      
      // goof for n>=1
      // recursion relation from
      // http://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials
      for(k=2; k<=n; k++)
	{
	  //L[k] = ((2*k-1.0+alpha-r)*L[k-1] + (-k+1.0-alpha)*L[k-2])/(k);
	  L[k] = (2+(alpha-1.0-x)/k)*L[k-1] - (1+(alpha-1.0)/k)*L[k-2];
	}

      return L[n];

    }
}

// calculates log(n!)
double logfact(int n)
{
  int i;
  double sum;
  
  if(n == 0)
    {
      return 0;
    }
  else
    {      
      sum = 0;
      for(i=1; i<=n; i++)
	{
	  sum += log(i);
	}      
      return sum;
    }
  
} // end logfact

// calculates log(n!!)
double logoddfact(int n)
{
  int i,k;
  double sum;
  
  if(n%2==0)
    {
      cout << "Not odd!" << endl;
      return 0;
    } 
  else
    {  
      k = (n+1)/2;
      sum = 0;
      for(i=1; i<=k; i++)
	{
	  sum += log(2*i-1);
	}       
      return sum;
    }
  
} // end logoddfact
